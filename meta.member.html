<!DOCTYPE html><html lang='en'><head><title>[meta.member]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.15</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#member'>[meta]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.15.9</a> Member relationships <a class='abbr_ref'>[meta.member]</a></h3><span class='indexparent'><a class='index' id='lib:is_pointer_interconvertible_with_class'></a></span><div class='itemdecl' id='itemdecl:1'><div class='marginalizedparent'><a class='itemDeclLink' href='#itemdecl:1'>🔗</a></div><code class='itemdeclcode'><span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> S, <span class='keyword'>class</span> M<span class='anglebracket'>&gt;</span>
  <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> is_pointer_interconvertible_with_class<span class='parenthesis'>(</span>M S<span class='operator'>::</span><span class='operator'>*</span>m<span class='parenthesis'>)</span> <span class='keyword'>noexcept</span>;
</code></div><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/utilities.tex#L18078'>#</a></div><div id='1.sentence-1' class='sentence'><span class='textit'>Mandates:</span> 
<span class='texttt'>S</span> is a complete type<a class='hidden_link' href='#1.sentence-1'>.</a></div></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/utilities.tex#L18082'>#</a></div><div id='2.sentence-1' class='sentence'><span class='textit'>Returns:</span> 
<span class='texttt'><span class='literal'>true</span></span> if and only if
 <span class='texttt'>S</span> is a standard-layout type,
 <span class='texttt'>M</span> is an object type,
 <span class='texttt'>m</span> is not null,
 and each object <span class='texttt'>s</span> of type <span class='texttt'>S</span>
 is pointer-interconvertible (<a href='basic.compound'>[basic.compound]</a>)
 with its subobject <span class='texttt'>s<span class='operator'>.</span><span class='operator'>*</span>m</span><a class='hidden_link' href='#2.sentence-1'>.</a></div></div></div><span class='indexparent'><a class='index' id='lib:is_corresponding_member'></a></span><div class='itemdecl' id='itemdecl:2'><div class='marginalizedparent'><a class='itemDeclLink' href='#itemdecl:2'>🔗</a></div><code class='itemdeclcode'><span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> S1, <span class='keyword'>class</span> S2, <span class='keyword'>class</span> M1, <span class='keyword'>class</span> M2<span class='anglebracket'>&gt;</span>
  <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> is_corresponding_member<span class='parenthesis'>(</span>M1 S1<span class='operator'>::</span><span class='operator'>*</span>m1, M2 S2<span class='operator'>::</span><span class='operator'>*</span>m2<span class='parenthesis'>)</span> <span class='keyword'>noexcept</span>;
</code></div><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/utilities.tex#L18100'>#</a></div><div id='3.sentence-1' class='sentence'><span class='textit'>Mandates:</span> 
<span class='texttt'>S1</span> and <span class='texttt'>S2</span> are complete types<a class='hidden_link' href='#3.sentence-1'>.</a></div></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/utilities.tex#L18104'>#</a></div><div id='4.sentence-1' class='sentence'><span class='textit'>Returns:</span> 
<span class='texttt'><span class='literal'>true</span></span> if and only if
 <span class='texttt'>S1</span> and <span class='texttt'>S2</span> are standard-layout types,
 <span class='texttt'>M1</span> and <span class='texttt'>M2</span> are object types,
 <span class='texttt'>m1</span> and <span class='texttt'>m2</span> are not null,
 and <span class='texttt'>m1</span> and <span class='texttt'>m2</span> point to corresponding members of
 the common initial sequence (<a href='class.mem'>[class.mem]</a>) of <span class='texttt'>S1</span> and <span class='texttt'>S2</span><a class='hidden_link' href='#4.sentence-1'>.</a></div></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/utilities.tex#L18114'>#</a></div><div id='5.note-1' class='note'>[&nbsp;<a class='note_link' href='#5.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='5.sentence-1' class='sentence'>The type of a pointer-to-member expression <span class='texttt'><span class='operator'>&amp;</span>C<span class='operator'>&#x200b;::&#x200b;</span>b</span>
is not always a pointer to member of <span class='texttt'>C</span>,
leading to potentially surprising results
when using these functions in conjunction with inheritance<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.example-1' class='example'>[&nbsp;<a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='keyword'>int</span> a; <span class='curlybracket'>}</span>;                    <span class='comment'>// a standard-layout class</span>
<span class='keyword'>struct</span> B <span class='curlybracket'>{</span> <span class='keyword'>int</span> b; <span class='curlybracket'>}</span>;                    <span class='comment'>// a standard-layout class</span>
<span class='keyword'>struct</span> C<span class='operator'>:</span> <span class='keyword'>public</span> A, <span class='keyword'>public</span> B <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;       <span class='comment'>// not a standard-layout class</span>

<span class='keyword'>static_assert</span><span class='parenthesis'>(</span> is_pointer_interconvertible_with_class<span class='parenthesis'>(</span> <span class='operator'>&amp;</span>C<span class='operator'>::</span>b <span class='parenthesis'>)</span> <span class='parenthesis'>)</span>;
  <span class='comment'>// Succeeds because, despite its appearance, <span class='tcode_in_codeblock'>&amp;C&#x200b;::&#x200b;b</span> has type</span>
  <span class='comment'>// “pointer to member of <span class='tcode_in_codeblock'>B</span> of type <span class='tcode_in_codeblock'>int</span>”.</span>
<span class='keyword'>static_assert</span><span class='parenthesis'>(</span> is_pointer_interconvertible_with_class<span class='anglebracket'>&lt;</span>C<span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span> <span class='operator'>&amp;</span>C<span class='operator'>::</span>b <span class='parenthesis'>)</span> <span class='parenthesis'>)</span>;
  <span class='comment'>// Forces the use of class <span class='tcode_in_codeblock'>C</span>, and fails.</span>

<span class='keyword'>static_assert</span><span class='parenthesis'>(</span> is_corresponding_member<span class='parenthesis'>(</span> <span class='operator'>&amp;</span>C<span class='operator'>::</span>a, <span class='operator'>&amp;</span>C<span class='operator'>::</span>b <span class='parenthesis'>)</span> <span class='parenthesis'>)</span>;
  <span class='comment'>// Succeeds because, despite its appearance, <span class='tcode_in_codeblock'>&amp;C&#x200b;::&#x200b;a</span> and <span class='tcode_in_codeblock'>&amp;C&#x200b;::&#x200b;b</span> have types</span>
  <span class='comment'>// “pointer to member of <span class='tcode_in_codeblock'>A</span> of type <span class='tcode_in_codeblock'>int</span>” and</span>
  <span class='comment'>// “pointer to member of <span class='tcode_in_codeblock'>B</span> of type <span class='tcode_in_codeblock'>int</span>”, respectively.</span>
<span class='keyword'>static_assert</span><span class='parenthesis'>(</span> is_corresponding_member<span class='anglebracket'>&lt;</span>C, C<span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span> <span class='operator'>&amp;</span>C<span class='operator'>::</span>a, <span class='operator'>&amp;</span>C<span class='operator'>::</span>b <span class='parenthesis'>)</span> <span class='parenthesis'>)</span>;
  <span class='comment'>// Forces the use of class <span class='tcode_in_codeblock'>C</span>, and fails.</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  —&nbsp;<i>end note</i></div>&nbsp;]</div> </div></div></body></html>