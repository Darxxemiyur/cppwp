<!DOCTYPE html><html lang='en'><head><title>[temp.deduct.call]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.10</a> Function template specializations <a class='abbr_ref' href='temp.fct.spec#temp.deduct.call'>[temp.fct.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>13.10.2</a> Template argument deduction <a class='abbr_ref' href='temp.deduct#call'>[temp.deduct]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>13.10.2.1</a> Deducing template arguments from a function call <a class='abbr_ref'>[temp.deduct.call]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L7814'>#</a></div><div id='1.sentence-1' class='sentence'>Template argument deduction is done by comparing each function
template parameter type (call it
<span class='texttt'>P</span>)
that contains <a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span> that participate in template argument deduction
with the type of the corresponding argument of the call (call it
<span class='texttt'>A</span>)
as described below<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>If removing references and cv-qualifiers from <span class='texttt'>P</span> gives
<span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span>P</span></span></span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.515em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span><span class="mjx-texatom"><span class="mjx-mrow"></span></span></span></span></span></span><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;"><span class='anglebracket'>&gt;</span></span></span></span></span></span></span></span>
or <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span></span></span><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.519em; padding-bottom: 0.372em;"><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span></span></span></span></span></span></span></span>
for some <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span></span></span></span></span></span> and <span class='texttt'>N</span> and the
argument is a non-empty initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), then deduction is
performed instead for each element of the initializer list independently,
taking <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span></span></span></span></span></span>
as separate function template parameter types <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-stack" style="vertical-align: -0.302em;"><span class="mjx-sup" style="font-size: 70.7%; padding-bottom: 0.255em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span></span><span class="mjx-sub" style="font-size: 70.7%; padding-right: 0.071em;"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.446em; padding-bottom: 0.298em;">i</span></span></span></span></span></span></span></span>
and the <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.446em; padding-bottom: 0.298em;">i</span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">th</span></span></span></span></span></span></span> initializer element as the corresponding argument<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>In the <span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msup"><span class="mjx-base"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;"><span class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.298em; padding-bottom: 0.298em;">′</span></span></span></span><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.519em; padding-bottom: 0.372em;"><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span></span></span></span></span></span></span></span> case, if <span class='texttt'>N</span> is a non-type template parameter,
<span class='texttt'>N</span> is deduced from the length of the initializer list<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context (<a href='temp.deduct.type'>[temp.deduct.type]</a>)<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.example-1' class='example'>[&nbsp;<a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span>,<span class='literal'>3</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                     <span class='comment'>// <span class='tcode_in_codeblock'>T</span> deduced as <span class='tcode_in_codeblock'>int</span></span>
f<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>"asdf"</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                  <span class='comment'>// error: <span class='tcode_in_codeblock'>T</span> deduced as both <span class='tcode_in_codeblock'>int</span> and <span class='tcode_in_codeblock'>const char*</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;
g<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span>,<span class='literal'>3</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                     <span class='comment'>// error: no argument deduced for <span class='tcode_in_codeblock'>T</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>int</span> N<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> h<span class='parenthesis'>(</span>T <span class='keyword'>const</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
h<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span>,<span class='literal'>3</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                     <span class='comment'>// <span class='tcode_in_codeblock'>T</span> deduced as <span class='tcode_in_codeblock'>int</span>; <span class='tcode_in_codeblock'>N</span> deduced as <span class='tcode_in_codeblock'>3</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> j<span class='parenthesis'>(</span>T <span class='keyword'>const</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='literal'>3</span><span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
j<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>42</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                        <span class='comment'>// <span class='tcode_in_codeblock'>T</span> deduced as <span class='tcode_in_codeblock'>int</span>; array bound not considered</span>

<span class='keyword'>struct</span> Aggr <span class='curlybracket'>{</span> <span class='keyword'>int</span> i; <span class='keyword'>int</span> j; <span class='curlybracket'>}</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>int</span> N<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> k<span class='parenthesis'>(</span>Aggr <span class='keyword'>const</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
k<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span>,<span class='literal'>3</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                     <span class='comment'>// error: deduction fails, no conversion from <span class='tcode_in_codeblock'>int</span> to <span class='tcode_in_codeblock'>Aggr</span></span>
k<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='curlybracket'>{</span><span class='literal'>1</span><span class='curlybracket'>}</span>,<span class='curlybracket'>{</span><span class='literal'>2</span><span class='curlybracket'>}</span>,<span class='curlybracket'>{</span><span class='literal'>3</span><span class='curlybracket'>}</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;               <span class='comment'>// OK, <span class='tcode_in_codeblock'>N</span> deduced as <span class='tcode_in_codeblock'>3</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>int</span> M, <span class='keyword'>int</span> N<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> m<span class='parenthesis'>(</span><span class='keyword'>int</span> <span class='keyword'>const</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span>M<span class='squarebracket'>]</span><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
m<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span><span class='curlybracket'>}</span>,<span class='curlybracket'>{</span><span class='literal'>3</span>,<span class='literal'>4</span><span class='curlybracket'>}</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;               <span class='comment'>// <span class='tcode_in_codeblock'>M</span> and <span class='tcode_in_codeblock'>N</span> both deduced as <span class='tcode_in_codeblock'>2</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>int</span> N<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> n<span class='parenthesis'>(</span>T <span class='keyword'>const</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span>, T<span class='parenthesis'>)</span>;
n<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='curlybracket'>{</span><span class='literal'>1</span><span class='curlybracket'>}</span>,<span class='curlybracket'>{</span><span class='literal'>2</span><span class='curlybracket'>}</span>,<span class='curlybracket'>{</span><span class='literal'>3</span><span class='curlybracket'>}</span><span class='curlybracket'>}</span>,Aggr<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;        <span class='comment'>// OK, <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>Aggr</span>, <span class='tcode_in_codeblock'>N</span> is <span class='tcode_in_codeblock'>3</span></span>

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>typename</span> T, <span class='keyword'>int</span> N<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> o<span class='parenthesis'>(</span>T <span class='parenthesis'>(</span><span class='operator'>*</span> <span class='keyword'>const</span> <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span>N<span class='squarebracket'>]</span><span class='parenthesis'>)</span><span class='parenthesis'>(</span>T<span class='parenthesis'>)</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>
<span class='keyword'>int</span> f1<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f4<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
<span class='keyword'>char</span> f4<span class='parenthesis'>(</span><span class='keyword'>char</span><span class='parenthesis'>)</span>;
o<span class='parenthesis'>(</span><span class='curlybracket'>{</span> <span class='operator'>&amp;</span>f1, <span class='operator'>&amp;</span>f4 <span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                                <span class='comment'>// OK, <span class='tcode_in_codeblock'>T</span> deduced as <span class='tcode_in_codeblock'>int</span> from first element, nothing</span>
                                                <span class='comment'>// deduced from second element, <span class='tcode_in_codeblock'>N</span> deduced as <span class='tcode_in_codeblock'>2</span></span>
o<span class='parenthesis'>(</span><span class='curlybracket'>{</span> <span class='operator'>&amp;</span>f1, <span class='keyword'>static_cast</span><span class='anglebracket'>&lt;</span><span class='keyword'>char</span><span class='parenthesis'>(</span><span class='operator'>*</span><span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='keyword'>char</span><span class='parenthesis'>)</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span>f4<span class='parenthesis'>)</span> <span class='curlybracket'>}</span><span class='parenthesis'>)</span>;    <span class='comment'>// error: conflicting deductions for <span class='tcode_in_codeblock'>T</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='1.sentence-5' class='sentence'>
For a function parameter pack that occurs at the end
of the <a class='grammarterm' href='dcl.fct#nt:parameter-declaration-list'>parameter-declaration-list</a>,
deduction is performed for each remaining argument of the call,
taking the type <span class='texttt'>P</span>
of the <a class='grammarterm' href='dcl.decl#nt:declarator-id'>declarator-id</a> of the function parameter pack
as the corresponding function template parameter type<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>Each deduction deduces template arguments for subsequent positions in
the template parameter packs expanded by the function parameter pack<a class='hidden_link' href='#1.sentence-6'>.</a></div> <div id='1.sentence-7' class='sentence'>When a function parameter pack appears in a non-deduced
context (<a href='temp.deduct.type'>[temp.deduct.type]</a>), the type of that pack is
never deduced<a class='hidden_link' href='#1.sentence-7'>.</a></div> <div id='1.example-2' class='example'>[&nbsp;<a class='example_link' href='#1.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> Types<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>Types<span class='operator'>&amp;</span> <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T1, <span class='keyword'>class</span> <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> Types<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T1, Types <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T1, <span class='keyword'>class</span> <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> Types<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g1<span class='parenthesis'>(</span>Types <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span>, T1<span class='parenthesis'>)</span>;

<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='keyword'>int</span> x, <span class='keyword'>float</span><span class='operator'>&amp;</span> y<span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>const</span> <span class='keyword'>int</span> z <span class='operator'>=</span> x;
  f<span class='parenthesis'>(</span>x, y, z<span class='parenthesis'>)</span>;                   <span class='comment'>// <span class='tcode_in_codeblock'>Types</span> deduced as <span class='tcode_in_codeblock'>int</span>, <span class='tcode_in_codeblock'>float</span>, <span class='tcode_in_codeblock'>const int</span></span>
  g<span class='parenthesis'>(</span>x, y, z<span class='parenthesis'>)</span>;                   <span class='comment'>// <span class='tcode_in_codeblock'>T1</span> deduced as <span class='tcode_in_codeblock'>int</span>; <span class='tcode_in_codeblock'>Types</span> deduced as <span class='tcode_in_codeblock'>float</span>, <span class='tcode_in_codeblock'>int</span></span>
  g1<span class='parenthesis'>(</span>x, y, z<span class='parenthesis'>)</span>;                  <span class='comment'>// error: <span class='tcode_in_codeblock'>Types</span> is not deduced</span>
  g1<span class='anglebracket'>&lt;</span><span class='keyword'>int</span>, <span class='keyword'>int</span>, <span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span>x, y, z<span class='parenthesis'>)</span>;   <span class='comment'>// OK, no deduction occurs</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L7897'>#</a></div><div id='2.sentence-1' class='sentence'>If
<span class='texttt'>P</span>
is not a reference type:</div><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><div id='2.1.sentence-1' class='sentence'>If
<span class='texttt'>A</span>
is an array type, the pointer type produced by the <a href='conv.array'>array-to-pointer
standard conversion</a> is used in place of
<span class='texttt'>A</span>
for type deduction;
otherwise,</div></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><div id='2.2.sentence-1' class='sentence'>If
<span class='texttt'>A</span>
is a function type, the pointer type produced by the
<a href='conv.func'>function-to-pointer standard conversion</a> is used in place
of
<span class='texttt'>A</span>
for type
deduction; otherwise,</div></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><div id='2.3.sentence-1' class='sentence'>If
<span class='texttt'>A</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction<a class='hidden_link' href='#2.3.sentence-1'>.</a></div></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L7928'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':reference,forwarding'></a></span>If
<span class='texttt'>P</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>If
<span class='texttt'>P</span>
is a reference type, the type
referred to by
<span class='texttt'>P</span>
is used for type deduction<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.example-1' class='example'>[&nbsp;<a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> T<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> n1 <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='literal'>5</span><span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&gt;(const int&amp;)</span></span>
<span class='keyword'>const</span> <span class='keyword'>int</span> i <span class='operator'>=</span> <span class='literal'>0</span>;
<span class='keyword'>int</span> n2 <span class='operator'>=</span> f<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&gt;(const int&amp;)</span></span>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>volatile</span> T<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> n3 <span class='operator'>=</span> g<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>g&lt;const int&gt;(const volatile int&amp;)</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='3.sentence-3' class='sentence'>
A <a class='hidden_link' href='#def:forwarding_reference' id='def:forwarding_reference'><i >forwarding reference</i></a>
is an rvalue reference to a cv-unqualified template parameter
that does not represent a template parameter of a class template
(during class template argument deduction (<a href='over.match.class.deduct'>[over.match.class.deduct]</a>))<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>If <span class='texttt'>P</span> is a forwarding reference and the argument is an
lvalue, the type “lvalue reference to <span class='texttt'>A</span>” is used in place of <span class='texttt'>A</span> for type
deduction<a class='hidden_link' href='#3.sentence-4'>.</a></div> <div id='3.example-2' class='example'>[&nbsp;<a class='example_link' href='#3.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> f<span class='parenthesis'>(</span>T<span class='operator'>&amp;</span><span class='operator'>&amp;</span> heisenreference<span class='parenthesis'>)</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> T<span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i;
<span class='keyword'>int</span> n1 <span class='operator'>=</span> f<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&amp;&gt;(int&amp;)</span></span>
<span class='keyword'>int</span> n2 <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='literal'>0</span><span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&gt;(int&amp;&amp;)</span></span>
<span class='keyword'>int</span> n3 <span class='operator'>=</span> g<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                  <span class='comment'>// error: would call <span class='tcode_in_codeblock'>g&lt;int&gt;(const int&amp;&amp;)</span>, which</span>
                                <span class='comment'>// would bind an rvalue reference to an lvalue</span>

<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> U<span class='anglebracket'>&gt;</span>
    A<span class='parenthesis'>(</span>T<span class='operator'>&amp;</span><span class='operator'>&amp;</span>, U<span class='operator'>&amp;</span><span class='operator'>&amp;</span>, <span class='keyword'>int</span><span class='operator'>*</span><span class='parenthesis'>)</span>;          <span class='comment'>// #1: <span class='tcode_in_codeblock'>T&amp;&amp;</span> is not a forwarding reference.</span>
                                <span class='comment'>// <span class='tcode_in_codeblock'>U&amp;&amp;</span> is a forwarding reference.</span>
  A<span class='parenthesis'>(</span>T<span class='operator'>&amp;</span><span class='operator'>&amp;</span>, <span class='keyword'>int</span><span class='operator'>*</span><span class='parenthesis'>)</span>;                 <span class='comment'>// #2</span>
<span class='curlybracket'>}</span>;

<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> A<span class='parenthesis'>(</span>T<span class='operator'>&amp;</span><span class='operator'>&amp;</span>, <span class='keyword'>int</span><span class='operator'>*</span><span class='parenthesis'>)</span> <span class='operator'>-</span><span class='anglebracket'>&gt;</span> A<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span>;    <span class='comment'>// #3: <span class='tcode_in_codeblock'>T&amp;&amp;</span> is a forwarding reference.</span>

<span class='keyword'>int</span> <span class='operator'>*</span>ip;
A a<span class='curlybracket'>{</span>i, <span class='literal'>0</span>, ip<span class='curlybracket'>}</span>;                  <span class='comment'>// error: cannot deduce from #1</span>
A a0<span class='curlybracket'>{</span><span class='literal'>0</span>, <span class='literal'>0</span>, ip<span class='curlybracket'>}</span>;                 <span class='comment'>// uses #1 to deduce <span class='tcode_in_codeblock'>A&lt;int&gt;</span> and #1 to initialize</span>
A a2<span class='curlybracket'>{</span>i, ip<span class='curlybracket'>}</span>;                    <span class='comment'>// uses #3 to deduce <span class='tcode_in_codeblock'>A&lt;int&amp;&gt;</span> and #2 to initialize</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L7984'>#</a></div><div id='4.sentence-1' class='sentence'>In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>
(after
the type
<span class='texttt'>A</span>
is transformed as described above)<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>However, there are
three cases that allow a difference:</div><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><div id='4.1.sentence-1' class='sentence'>If the original
<span class='texttt'>P</span>
is a reference type, the deduced
<span class='texttt'>A</span>
(i.e.,
the type referred to by the reference) can be more cv-qualified than
the transformed <span class='texttt'>A</span><a class='hidden_link' href='#4.1.sentence-1'>.</a></div></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><div id='4.2.sentence-1' class='sentence'>The transformed <span class='texttt'>A</span>
can be another pointer or pointer-to-member type that can be converted
to the deduced
<span class='texttt'>A</span>
via a <a href='conv.fctptr'>function pointer conversion</a> and/or
<a href='conv.qual'>qualification conversion</a><a class='hidden_link' href='#4.2.sentence-1'>.</a></div></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><div id='4.3.sentence-1' class='sentence'>If
<span class='texttt'>P</span>
is a class and
<span class='texttt'>P</span>
has the form
<a class='grammarterm' href='temp.names#nt:simple-template-id'>simple-template-id</a>,
then
the transformed <span class='texttt'>A</span>
can be a derived class <span class='texttt'>D</span> of the
deduced
<span class='texttt'>A</span><a class='hidden_link' href='#4.3.sentence-1'>.</a></div> <div id='4.3.sentence-2' class='sentence'>Likewise, if
<span class='texttt'>P</span>
is a pointer to a class of the form
<a class='grammarterm' href='temp.names#nt:simple-template-id'>simple-template-id</a>,
the transformed <span class='texttt'>A</span>
can be a pointer to a
derived class <span class='texttt'>D</span> pointed to by the deduced
<span class='texttt'>A</span><a class='hidden_link' href='#4.3.sentence-2'>.</a></div> <div id='4.3.sentence-3' class='sentence'>However, if there is a class <span class='texttt'>C</span> that is
a (direct or indirect) base class of <span class='texttt'>D</span> and
derived (directly or indirectly) from a class <span class='texttt'>B</span> and
that would be a valid deduced <span class='texttt'>A</span>,
the deduced <span class='texttt'>A</span> cannot be <span class='texttt'>B</span> or pointer to <span class='texttt'>B</span>,
respectively<a class='hidden_link' href='#4.3.sentence-3'>.</a></div> <div id='4.3.example-1' class='example'>[&nbsp;<a class='example_link' href='#4.3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> X;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> X<span class='anglebracket'>&lt;</span><span class='anglebracket'>&gt;</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span> T, <span class='keyword'>typename</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> Ts<span class='anglebracket'>&gt;</span>
  <span class='keyword'>struct</span> X<span class='anglebracket'>&lt;</span>T, Ts<span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='anglebracket'>&gt;</span> <span class='operator'>:</span> X<span class='anglebracket'>&lt;</span>Ts<span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='anglebracket'>&gt;</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> D <span class='operator'>:</span> X<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;

<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> T<span class='anglebracket'>&gt;</span>
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> X<span class='anglebracket'>&lt;</span>T<span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='anglebracket'>&gt;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> x <span class='operator'>=</span> f<span class='parenthesis'>(</span>D<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;     <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&gt;</span>, not <span class='tcode_in_codeblock'>f&lt;&gt;</span></span>
                    <span class='comment'>// <span class='tcode_in_codeblock'>B</span> is <span class='tcode_in_codeblock'>X&lt;&gt;</span>, <span class='tcode_in_codeblock'>C</span> is <span class='tcode_in_codeblock'>X&lt;int&gt;</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8056'>#</a></div><div id='5.sentence-1' class='sentence'>These alternatives are considered only if type deduction would
otherwise fail<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.sentence-2' class='sentence'>If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails<a class='hidden_link' href='#5.sentence-2'>.</a></div> <div id='5.note-1' class='note'>[&nbsp;<a class='note_link' href='#5.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='5.sentence-3' class='sentence'>If a
<a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a>
is not used in any of the function parameters of a function template,
or is used only in a non-deduced context, its corresponding
<a class='grammarterm' href='temp.names#nt:template-argument'>template-argument</a>
cannot be deduced from a function call and the
<a class='grammarterm' href='temp.names#nt:template-argument'>template-argument</a>
must be explicitly specified<a class='hidden_link' href='#5.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8073'>#</a></div><div id='6.sentence-1' class='sentence'>When
<span class='texttt'>P</span>
is a function type, function pointer type, or pointer-to-member-function type:
<ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div>If the argument is an overload set containing one or more function templates,
the parameter is treated as a non-deduced context.</li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div>If the argument is an overload set (not containing function templates), trial
argument deduction is attempted using each of the members of the set. If
deduction succeeds for only one of the overload set members, that member is
used as the argument value for the deduction. If deduction succeeds for more than
one member of the overload set the parameter is treated as a non-deduced context.</li></ul></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8089'>#</a></div><div id='7.example-1' class='example'>[&nbsp;<a class='example_link' href='#7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='comment'>// Only one function of an overload set matches the call so the function parameter is a deduced context.</span>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> f<span class='parenthesis'>(</span>T <span class='parenthesis'>(</span><span class='operator'>*</span>p<span class='parenthesis'>)</span><span class='parenthesis'>(</span>T<span class='parenthesis'>)</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>char</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span>g<span class='parenthesis'>)</span>;       <span class='comment'>// calls <span class='tcode_in_codeblock'>f(int (*)(int))</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8100'>#</a></div><div id='8.example-1' class='example'>[&nbsp;<a class='example_link' href='#8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='comment'>// Ambiguous deduction causes the second function parameter to be a non-deduced context.</span>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> f<span class='parenthesis'>(</span>T, T <span class='parenthesis'>(</span><span class='operator'>*</span>p<span class='parenthesis'>)</span><span class='parenthesis'>(</span>T<span class='parenthesis'>)</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
<span class='keyword'>char</span> g<span class='parenthesis'>(</span><span class='keyword'>char</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='literal'>1</span>, g<span class='parenthesis'>)</span>;    <span class='comment'>// calls <span class='tcode_in_codeblock'>f(int, int (*)(int))</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8111'>#</a></div><div id='9.example-1' class='example'>[&nbsp;<a class='example_link' href='#9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='comment'>// The overload set contains a template, causing the second function parameter to be a non-deduced context.</span>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> f<span class='parenthesis'>(</span>T, T <span class='parenthesis'>(</span><span class='operator'>*</span>p<span class='parenthesis'>)</span><span class='parenthesis'>(</span>T<span class='parenthesis'>)</span><span class='parenthesis'>)</span>;
<span class='keyword'>char</span> g<span class='parenthesis'>(</span><span class='keyword'>char</span><span class='parenthesis'>)</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> T g<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='literal'>1</span>, g<span class='parenthesis'>)</span>;    <span class='comment'>// calls <span class='tcode_in_codeblock'>f(int, int (*)(int))</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L8122'>#</a></div><div id='10.sentence-1' class='sentence'>If deduction succeeds for all parameters that contain
<a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span> that participate in template argument
deduction, and all template arguments are explicitly specified, deduced,
or obtained from default template arguments, remaining parameters are then
compared with the corresponding arguments<a class='hidden_link' href='#10.sentence-1'>.</a></div> <div id='10.sentence-2' class='sentence'>For each remaining parameter
<span class='texttt'>P</span> with a type that was non-dependent before substitution of any
explicitly-specified template arguments, if the corresponding argument
<span class='texttt'>A</span> cannot be implicitly converted to <span class='texttt'>P</span>, deduction fails<a class='hidden_link' href='#10.sentence-2'>.</a></div> <div id='10.note-1' class='note'>[&nbsp;<a class='note_link' href='#10.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='10.sentence-3' class='sentence'>Parameters with dependent types in which no <a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span>
participate in template argument deduction, and parameters that became
non-dependent due to substitution of explicitly-specified template arguments,
will be checked during overload resolution<a class='hidden_link' href='#10.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='10.example-1' class='example'>[&nbsp;<a class='example_link' href='#10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> Z <span class='curlybracket'>{</span>
  <span class='keyword'>typedef</span> <span class='keyword'>typename</span> T<span class='operator'>::</span>x xx;
<span class='curlybracket'>}</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>typename</span> Z<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span><span class='operator'>::</span>xx f<span class='parenthesis'>(</span><span class='keyword'>void</span> <span class='operator'>*</span>, T<span class='parenthesis'>)</span>;      <span class='comment'>// #1</span>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span>, T<span class='parenthesis'>)</span>;                      <span class='comment'>// #2</span>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span> a;
<span class='keyword'>int</span> main<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  f<span class='parenthesis'>(</span><span class='literal'>1</span>, a<span class='parenthesis'>)</span>;          <span class='comment'>// OK, deduction fails for #1 because there is no conversion from <span class='tcode_in_codeblock'>int</span> to <span class='tcode_in_codeblock'>void*</span></span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div></div></body></html>