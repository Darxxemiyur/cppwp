<!DOCTYPE html><html lang='en'><head><title>[atomics.ref.int]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>31</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>31.7</a> Class template <span class='texttt'>atomic_&shy;ref</span> <a class='abbr_ref' href='atomics.ref.generic#atomics.ref.int'>[atomics.ref.generic]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>31.7.2</a> Specializations for integral types <a class='abbr_ref'>[atomics.ref.int]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1115'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>'></a></span>There are specializations of the <span class='texttt'>atomic_&shy;ref</span> class template
for the integral types
<span class='texttt'><span class='keyword'>char</span></span>,
<span class='texttt'><span class='keyword'>signed</span> <span class='keyword'>char</span></span>,
<span class='texttt'><span class='keyword'>unsigned</span> <span class='keyword'>char</span></span>,
<span class='texttt'><span class='keyword'>short</span></span>,
<span class='texttt'><span class='keyword'>unsigned</span> <span class='keyword'>short</span></span>,
<span class='texttt'><span class='keyword'>int</span></span>,
<span class='texttt'><span class='keyword'>unsigned</span> <span class='keyword'>int</span></span>,
<span class='texttt'><span class='keyword'>long</span></span>,
<span class='texttt'><span class='keyword'>unsigned</span> <span class='keyword'>long</span></span>,
<span class='texttt'><span class='keyword'>long</span> <span class='keyword'>long</span></span>,
<span class='texttt'><span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span></span>,
<span class='texttt'><span class='keyword'>char8_&shy;t</span></span>,
<span class='texttt'><span class='keyword'>char16_&shy;t</span></span>,
<span class='texttt'><span class='keyword'>char32_&shy;t</span></span>,
<span class='texttt'><span class='keyword'>wchar_&shy;t</span></span>,
and any other types needed by the typedefs in the header <span class='indexparent'><a class='index' id=':<cstdint>'></a></span><span class='texttt'><span class='anglebracket'>&lt;</span>cstdint<span class='anglebracket'>&gt;</span></span> (<a href='cstdint.syn'>[cstdint.syn]</a>)<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>For each such type <span class='texttt'><span class='textit'>integral</span></span>,
the specialization <span class='texttt'>atomic_&shy;ref<span class='anglebracket'>&lt;</span><span class='textit'>integral</span><span class='anglebracket'>&gt;</span></span> provides
additional atomic operations appropriate to integral types<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.note-1' class='note'>[&nbsp;<a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-3' class='sentence'>The specialization <span class='texttt'>atomic_&shy;ref<span class='anglebracket'>&lt;</span><span class='keyword'>bool</span><span class='anglebracket'>&gt;</span></span>
uses the primary template (<a href='atomics.ref.generic'>[atomics.ref.generic]</a>)<a class='hidden_link' href='#1.sentence-3'>.</a></div> â€”&nbsp;<i>end note</i></div>&nbsp;]</div> <pre class='codeblock'>
<span class='keyword'>namespace</span> std <span class='curlybracket'>{</span>
  <span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> atomic_ref<span class='anglebracket'>&lt;</span><span class='textit'>integral</span><span class='anglebracket'>&gt;</span> <span class='curlybracket'>{</span>
  <span class='keyword'>private</span><span class='operator'>:</span>
    <span class='textit'>integral</span><span class='operator'>*</span> ptr;        <span class='comment'>// <span class='textit'>exposition only</span></span>
  <span class='keyword'>public</span><span class='operator'>:</span>
    <span class='keyword'>using</span> value_type <span class='operator'>=</span> <span class='textit'>integral</span>;
    <span class='keyword'>using</span> difference_type <span class='operator'>=</span> value_type;
    <span class='keyword'>static</span> <span class='keyword'>constexpr</span> size_t required_alignment <span class='operator'>=</span> <span class='indexparent'><a class='index' id=':required_alignment_for_atomic_ref_type&#39;s_operations'></a></span><span class='textit'>implementation-defined</span>;

    <span class='keyword'>static</span> <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> is_always_lock_free <span class='operator'>=</span> <span class='indexparent'><a class='index' id=':whether_a_given_atomic_ref_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    <span class='keyword'>bool</span> is_lock_free<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>explicit</span> atomic_ref<span class='parenthesis'>(</span><span class='textit'>integral</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
    atomic_ref<span class='parenthesis'>(</span><span class='keyword'>const</span> atomic_ref<span class='operator'>&amp;</span><span class='parenthesis'>)</span> <span class='keyword'>noexcept</span>;
    atomic_ref<span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='keyword'>const</span> atomic_ref<span class='operator'>&amp;</span><span class='parenthesis'>)</span> <span class='operator'>=</span> <span class='keyword'>delete</span>;

    <span class='keyword'>void</span> store<span class='parenthesis'>(</span><span class='textit'>integral</span>, memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> load<span class='parenthesis'>(</span>memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>operator</span> <span class='textit'>integral</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='textit'>integral</span> exchange<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                      memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>bool</span> compare_exchange_weak<span class='parenthesis'>(</span><span class='textit'>integral</span><span class='operator'>&amp;</span>, <span class='textit'>integral</span>,
                               memory_order, memory_order<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>bool</span> compare_exchange_strong<span class='parenthesis'>(</span><span class='textit'>integral</span><span class='operator'>&amp;</span>, <span class='textit'>integral</span>,
                                 memory_order, memory_order<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>bool</span> compare_exchange_weak<span class='parenthesis'>(</span><span class='textit'>integral</span><span class='operator'>&amp;</span>, <span class='textit'>integral</span>,
                               memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>bool</span> compare_exchange_strong<span class='parenthesis'>(</span><span class='textit'>integral</span><span class='operator'>&amp;</span>, <span class='textit'>integral</span>,
                                 memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='textit'>integral</span> fetch_add<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                       memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> fetch_sub<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                       memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> fetch_and<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                       memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> fetch_or<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                      memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> fetch_xor<span class='parenthesis'>(</span><span class='textit'>integral</span>,
                       memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>&amp;</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>|</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='textit'>integral</span> <span class='keyword'>operator</span><span class='operator'>^</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>void</span> wait<span class='parenthesis'>(</span><span class='textit'>integral</span>, memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>void</span> notify_one<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>void</span> notify_all<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
  <span class='curlybracket'>}</span>;
<span class='curlybracket'>}</span>
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1204'>#</a></div><div id='2.sentence-1' class='sentence'>Descriptions are provided below only for members
that differ from the primary template<a class='hidden_link' href='#2.sentence-1'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1208'>#</a></div><div id='3.sentence-1' class='sentence'>The following operations perform arithmetic computations<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>The key, operator, and computation correspondence is identified
in Table <a href='atomics.types.int#tab:atomic.types.int.comp'>144</a><a class='hidden_link' href='#3.sentence-2'>.</a></div> <span class='indexparent'><a class='index' id='lib:fetch_add,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,fetch_add'></a></span><span class='indexparent'><a class='index' id='lib:fetch_and,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,fetch_and'></a></span><span class='indexparent'><a class='index' id='lib:fetch_or,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,fetch_or'></a></span><span class='indexparent'><a class='index' id='lib:fetch_sub,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,fetch_sub'></a></span><span class='indexparent'><a class='index' id='lib:fetch_xor,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,fetch_xor'></a></span></div><div class='itemdecl' id='itemdecl:1'><div class='marginalizedparent'><a class='itemDeclLink' href='#itemdecl:1'>ðŸ”—</a></div><code class='itemdeclcode'><span class='textit'>integral</span> fetch_<span class='textit'>key</span><span class='parenthesis'>(</span><span class='textit'>integral</span> operand, memory_order order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
</code></div><div class='itemdescr'></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1223'>#</a></div><div id='4.sentence-1' class='sentence'><span class='textit'>Effects:</span> 
Atomically replaces the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span> with
the result of the computation applied to the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span>
and the given operand<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>Memory is affected according to the value of <span class='texttt'>order</span><a class='hidden_link' href='#4.sentence-2'>.</a></div> <div id='4.sentence-3' class='sentence'>These operations are atomic read-modify-write operations (<a href='intro.races'>[intro.races]</a>)<a class='hidden_link' href='#4.sentence-3'>.</a></div></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1231'>#</a></div><div id='5.sentence-1' class='sentence'><span class='textit'>Returns:</span> 
Atomically, the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span>
immediately before the effects<a class='hidden_link' href='#5.sentence-1'>.</a></div></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1236'>#</a></div><div id='6.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':signed_integer_representation,two&#39;s_complement'></a></span><span class='textit'>Remarks:</span> 
For signed integer types,
the result is as if the object value and parameters
were converted to their corresponding unsigned types,
the computation performed on those types, and
the result converted back to the signed type<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.note-1' class='note'>[&nbsp;<a class='note_link' href='#6.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='6.sentence-2' class='sentence'>There are no undefined results arising from the computation<a class='hidden_link' href='#6.sentence-2'>.</a></div> â€”&nbsp;<i>end note</i></div>&nbsp;]</div> </div></div><span class='indexparent'><a class='index' id='lib:operator+=,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,operator+='></a></span><span class='indexparent'><a class='index' id='lib:operator-=,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,operator-='></a></span><span class='indexparent'><a class='index' id='lib:operator&amp;=,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,operator&amp;='></a></span><span class='indexparent'><a class='index' id='lib:operator|=,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,operator|='></a></span><span class='indexparent'><a class='index' id='lib:operator^=,atomic_ref<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic_ref<integral>,operator^='></a></span><div class='itemdecl' id='itemdecl:2'><div class='marginalizedparent'><a class='itemDeclLink' href='#itemdecl:2'>ðŸ”—</a></div><code class='itemdeclcode'><span class='textit'>integral</span> <span class='keyword'>operator</span> <span class='textit'>op</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='textit'>integral</span> operand<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
</code></div><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/atomics.tex#L1259'>#</a></div><div id='7.sentence-1' class='sentence'><span class='textit'>Effects:</span> 
Equivalent to:
<span class='texttt'><span class='keyword'>return</span> fetch_&shy;<span class='textit'>key</span><span class='parenthesis'>(</span>operand<span class='parenthesis'>)</span> <span class='textit'>op</span> operand;</span></div></div></div></div></body></html>