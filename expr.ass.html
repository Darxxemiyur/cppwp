<!DOCTYPE html><html lang='en'><head><title>[expr.ass]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.6</a> Compound expressions <a class='abbr_ref' href='expr.compound#expr.ass'>[expr.compound]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.6.19</a> Assignment and compound assignment operators <a class='abbr_ref'>[expr.ass]</a></h3><span class='indexparent'><a class='index' id=':expression,assignment_and_compound_assignment'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6631'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':operator,assignment'></a></span><span class='indexparent'><a class='index' id=':operator,+='></a></span><span class='indexparent'><a class='index' id=':operator,-='></a></span><span class='indexparent'><a class='index' id=':operator,*='></a></span><span class='indexparent'><a class='index' id=':operator,/='></a></span><span class='indexparent'><a class='index' id=':operator,%='></a></span><span class='indexparent'><a class='index' id=':operator,>>='></a></span><span class='indexparent'><a class='index' id=':operator,<<='></a></span><span class='indexparent'><a class='index' id=':operator,&amp;='></a></span><span class='indexparent'><a class='index' id=':operator,^='></a></span><span class='indexparent'><a class='index' id=':operator,|='></a></span>The assignment operator (<span class='texttt'><span class='operator'>=</span></span>) and the compound assignment
operators all group right-to-left<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'><span class='indexparent'><a class='index' id=':assignment,and_lvalue'></a></span>All
require a modifiable lvalue as their left operand; their result is an lvalue
referring to the left operand<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>The result in all cases is a bit-field if
the left operand is a bit-field<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>In all cases, the assignment is
sequenced after the
<span class='indexparent'><a class='index' id=':value_computation'></a></span>value computation of the right and left operands,
and before the
value computation of the assignment expression<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>The right operand is sequenced before the left operand<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>With
respect to an indeterminately-sequenced function call, the operation of
a compound assignment is a single evaluation<a class='hidden_link' href='#1.sentence-6'>.</a></div> <div id='1.note-1' class='note'>[&nbsp;<a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-7' class='sentence'>Therefore, a function call cannot intervene between the
lvalue-to-rvalue conversion and the side effect associated with any
single compound assignment operator<a class='hidden_link' href='#1.sentence-7'>.</a></div> â€”&nbsp;<i>end note</i></div>&nbsp;]</div> <pre class='bnf'><a class='nontermdef' href='#nt:assignment-expression' id='nt:assignment-expression'>assignment-expression</a><span class='ntdefcolon'>:</span>
&#9;<a class='grammarterm' href='expr.cond#nt:conditional-expression'>conditional-expression</a>
&#9;<a class='grammarterm' href='expr.yield#nt:yield-expression'>yield-expression</a>
&#9;<a class='grammarterm' href='expr.throw#nt:throw-expression'>throw-expression</a>
&#9;<a class='grammarterm' href='expr.log.or#nt:logical-or-expression'>logical-or-expression</a> <a class='grammarterm' href='#nt:assignment-operator'>assignment-operator</a> <a class='grammarterm' href='dcl.init#nt:initializer-clause'>initializer-clause</a>
</pre><pre class='bnf'><a class='nontermdef' href='#nt:assignment-operator' id='nt:assignment-operator'>assignment-operator</a><span class='ntdefcolon'>:</span> <span class='textnormal'>one of</span>
&#9;<span class='terminal'><span class='operator'>=</span>  <span class='operator'>*</span><span class='operator'>=</span>  <span class='operator'>/</span><span class='operator'>=</span>  <span class='operator'>%</span><span class='operator'>=</span>   <span class='operator'>+</span><span class='operator'>=</span>  <span class='operator'>-</span><span class='operator'>=</span>  <span class='anglebracket'>&gt;</span><span class='anglebracket'>&gt;</span><span class='operator'>=</span>  <span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span>  <span class='operator'>&amp;</span><span class='operator'>=</span>  <span class='operator'>^</span><span class='operator'>=</span>  <span class='operator'>|</span><span class='operator'>=</span></span>
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6679'>#</a></div><div id='2.sentence-1' class='sentence'>In simple assignment (<span class='texttt'><span class='operator'>=</span></span>), the object referred to by the left operand
is modified (<a href='defns.access'>[defns.access]</a>)
by replacing its value with the result of the right operand<a class='hidden_link' href='#2.sentence-1'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6684'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':assignment,conversion_by'></a></span>If the right operand is an expression, it is implicitly
<a href='conv'>converted</a> to the cv-unqualified type of the left
operand<a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6690'>#</a></div><div id='4.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':reference,assignment_to'></a></span>When the left operand of an assignment operator
is a bit-field that cannot represent the value of the expression, the
resulting value of the bit-field is
<span class='indexparent'><a class='index' id=':value_of_bit-field_that_cannot_represent,assigned_value'></a></span>implementation-defined<a class='hidden_link' href='#4.sentence-1'>.</a></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6697'>#</a></div><div id='5.sentence-1' class='sentence'>A simple assignment whose left operand is of
a volatile-qualified type is deprecated (<a href='depr.volatile.type'>[depr.volatile.type]</a>)
unless the (possibly parenthesized) assignment is a discarded-value expression or
an unevaluated operand<a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6703'>#</a></div><div id='6.sentence-1' class='sentence'>The behavior of an expression of the form <span class='texttt'>E1 <span class='textit'>op</span><span class='operator'>=</span> E2</span>
is equivalent to <span class='texttt'>E1 <span class='operator'>=</span> E1 <span class='textit'>op</span> E2</span> except
that <span class='texttt'>E1</span> is evaluated only once<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>Such expressions are deprecated
if <span class='texttt'>E1</span> has volatile-qualified type; see <a href='depr.volatile.type'>[depr.volatile.type]</a><a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>For <span class='texttt'><span class='operator'>+</span><span class='operator'>=</span></span> and <span class='texttt'><span class='operator'>-</span><span class='operator'>=</span></span>,
<span class='texttt'>E1</span> shall either have arithmetic type or be a pointer to a
possibly cv-qualified completely-defined object type<a class='hidden_link' href='#6.sentence-3'>.</a></div> <div id='6.sentence-4' class='sentence'>In all other
cases, <span class='texttt'>E1</span> shall have arithmetic type<a class='hidden_link' href='#6.sentence-4'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6714'>#</a></div><div id='7.sentence-1' class='sentence'>If the value being stored in an object is read via another object that
overlaps in any way the storage of the first object, then the overlap shall be
exact and the two objects shall have the same type, otherwise the behavior is
undefined<a class='hidden_link' href='#7.sentence-1'>.</a></div> <div id='7.note-1' class='note'>[&nbsp;<a class='note_link' href='#7.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='7.sentence-2' class='sentence'>This restriction applies to the relationship
between the left and right sides of the assignment operation; it is not a
statement about how the target of the assignment may be aliased in general<a class='hidden_link' href='#7.sentence-2'>.</a></div> <div id='7.sentence-3' class='sentence'>See <a href='basic.lval'>[basic.lval]</a><a class='hidden_link' href='#7.sentence-3'>.</a></div> â€”&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6726'>#</a></div><div id='8.sentence-1' class='sentence'>A <a class='grammarterm' href='dcl.init#nt:braced-init-list'>braced-init-list</a> may appear on the right-hand side of
<ul class='itemize'><li id='8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.1'>(8.1)</a></div>an assignment to a scalar, in which case the initializer list shall have
at most a single element. The meaning of <span class='texttt'>x <span class='operator'>=</span> <span class='curlybracket'>{</span>v<span class='curlybracket'>}</span></span>, where <span class='texttt'>T</span> is the
scalar type of the expression <span class='texttt'>x</span>, is that of <span class='texttt'>x <span class='operator'>=</span> T<span class='curlybracket'>{</span>v<span class='curlybracket'>}</span></span>. The meaning of
<span class='texttt'>x <span class='operator'>=</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span></span> is <span class='texttt'>x <span class='operator'>=</span> T<span class='curlybracket'>{</span><span class='curlybracket'>}</span></span>.</li><li id='8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.2'>(8.2)</a></div>an assignment to an object of class type, in which case the initializer
list is passed as the argument to the assignment operator function selected by
overload resolution (<a href='over.ass'>[over.ass]</a>, <a href='over.match'>[over.match]</a>).</li></ul></div> <div id='8.example-1' class='example'>[&nbsp;<a class='example_link' href='#8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
complex<span class='anglebracket'>&lt;</span><span class='keyword'>double</span><span class='anglebracket'>&gt;</span> z;
z <span class='operator'>=</span> <span class='curlybracket'>{</span> <span class='literal'>1</span>,<span class='literal'>2</span> <span class='curlybracket'>}</span>;        <span class='comment'>// meaning <span class='tcode_in_codeblock'>z.operator=({1,2})</span></span>
z <span class='operator'>+</span><span class='operator'>=</span> <span class='curlybracket'>{</span> <span class='literal'>1</span>, <span class='literal'>2</span> <span class='curlybracket'>}</span>;      <span class='comment'>// meaning <span class='tcode_in_codeblock'>z.operator+=({1,2})</span></span>
<span class='keyword'>int</span> a, b;
a <span class='operator'>=</span> b <span class='operator'>=</span> <span class='curlybracket'>{</span> <span class='literal'>1</span> <span class='curlybracket'>}</span>;      <span class='comment'>// meaning <span class='tcode_in_codeblock'>a=b=1;</span></span>
a <span class='operator'>=</span> <span class='curlybracket'>{</span> <span class='literal'>1</span> <span class='curlybracket'>}</span> <span class='operator'>=</span> b;      <span class='comment'>// syntax error</span>
</pre> â€”&nbsp;<i>end example</i></div>&nbsp;]</div> </div></div></body></html>