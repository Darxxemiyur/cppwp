<!DOCTYPE html><html lang='en'><head><title>[temp.func.order]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.7</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.func.order'>[temp.decls]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>13.7.6</a> Function templates <a class='abbr_ref' href='temp.fct#temp.func.order'>[temp.fct]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>13.7.6.2</a> Partial ordering of function templates <a class='abbr_ref'>[temp.func.order]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L3874'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,resolution,template'></a></span>If a function template is overloaded,
the use of a function template specialization might be ambiguous because
<a href='temp.deduct'>template argument deduction</a> may associate the function
template specialization with more than one function template declaration<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'><a class='hidden_link' href='#def:template,function,partial_ordering' id='def:template,function,partial_ordering'><i >Partial ordering</i></a>
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:
<ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div>during overload resolution for a call to a function template specialization (<a href='over.match.best'>[over.match.best]</a>);</li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div>when the address of a function template specialization is taken;</li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div>when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>);</li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div>when a <a href='temp.friend'>friend function declaration</a>, an
<a href='temp.explicit'>explicit instantiation</a> or an <a href='temp.expl.spec'>explicit specialization</a> refers to
a function template specialization<a class='hidden_link' href='#1.sentence-2'>.</a></li></ul></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L3901'>#</a></div><div id='2.sentence-1' class='sentence'>Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>The deduction process determines whether
one of the templates is more specialized than the other<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>If so, the
more specialized template is the one chosen by the partial ordering
process<a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.sentence-4' class='sentence'>If both deductions succeed, the partial ordering selects
the more constrained template (if one exists) as determined below<a class='hidden_link' href='#2.sentence-4'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L3913'>#</a></div><div id='3.sentence-1' class='sentence'>To produce the transformed template, for each type, non-type, or template
template parameter (including
<a href='temp.variadic#def:template_parameter_pack'>template parameter packs</a>
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.note-1' class='note'>[&nbsp;<a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-2' class='sentence'>The type replacing the placeholder
in the type of the value synthesized for a non-type template parameter
is also a unique synthesized type<a class='hidden_link' href='#3.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='3.sentence-3' class='sentence'>
Each function template <span class='math'><span class='mathalpha'>M</span></span> that is a member function
is considered to have
a new first parameter of type <span class='math'><span class='mathalpha'>X</span>(<span class='mathalpha'>M</span>)</span>, described below,
inserted in its function parameter list<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>If exactly one of the function templates was considered by overload resolution
via a rewritten candidate (<a href='over.match.oper'>[over.match.oper]</a>)
with a reversed order of parameters,
then the order of the function parameters in its transformed template
is reversed<a class='hidden_link' href='#3.sentence-4'>.</a></div> <div id='3.sentence-5' class='sentence'>For a function template <span class='math'><span class='mathalpha'>M</span></span> with cv-qualifiers <span class='mathit'>cv</span>
that is a member of a class <span class='math'><span class='mathalpha'>A</span></span>:</div><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'>The type <span class='math'><span class='mathalpha'>X</span>(<span class='mathalpha'>M</span>)</span> is “rvalue reference to <span class='mathit'>cv</span> <span class='math'><span class='mathalpha'>A</span></span>”
if the optional <a class='grammarterm' href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a> of
<span class='math'><span class='mathalpha'>M</span></span> is <span class='texttt'><span class='operator'>&amp;</span><span class='operator'>&amp;</span></span> or
if <span class='math'><span class='mathalpha'>M</span></span> has no <a class='grammarterm' href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a> and
the positionally-corresponding parameter of the other transformed template
has rvalue reference type;
if this determination depends recursively upon
whether <span class='math'><span class='mathalpha'>X</span>(<span class='mathalpha'>M</span>)</span> is an rvalue reference type,
it is not considered to have rvalue reference type<a class='hidden_link' href='#3.1.sentence-1'>.</a></div></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'>Otherwise, <span class='math'><span class='mathalpha'>X</span>(<span class='mathalpha'>M</span>)</span> is “lvalue reference to <span class='mathit'>cv</span> <span class='math'><span class='mathalpha'>A</span></span>”<a class='hidden_link' href='#3.2.sentence-1'>.</a></div></li></ul><div id='3.note-2' class='note'>[&nbsp;<a class='note_link' href='#3.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-6' class='sentence'>This allows a non-static
member to be ordered with respect to a non-member function and for the results
to be equivalent to the ordering of two equivalent non-members<a class='hidden_link' href='#3.sentence-6'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='3.example-1' class='example'>[&nbsp;<a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> B <span class='curlybracket'>{</span>
  <span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> R<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> <span class='keyword'>operator</span><span class='operator'>*</span><span class='parenthesis'>(</span>R<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;              <span class='comment'>// #1</span>
<span class='curlybracket'>}</span>;

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span> R<span class='anglebracket'>&gt;</span> <span class='keyword'>int</span> <span class='keyword'>operator</span><span class='operator'>*</span><span class='parenthesis'>(</span>T<span class='operator'>&amp;</span>, R<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;   <span class='comment'>// #2</span>

<span class='comment'>// The declaration of <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;operator*</span> is transformed into the equivalent of</span>
<span class='comment'>// <span class='tcode_in_codeblock'>template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;// #1a</span>

<span class='keyword'>int</span> main<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  A a;
  B<span class='anglebracket'>&lt;</span>A<span class='anglebracket'>&gt;</span> b;
  b <span class='operator'>*</span> a;                                            <span class='comment'>// calls #1</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L3978'>#</a></div><div id='4.sentence-1' class='sentence'>Using the transformed function template's function type,
perform type deduction against the other template as described in <a href='temp.deduct.partial'>[temp.deduct.partial]</a><a class='hidden_link' href='#4.sentence-1'>.</a></div><div style='height:0.6em;display:block'></div><div id='4.example-1' class='example'>[&nbsp;<a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> A <span class='curlybracket'>{</span> A<span class='parenthesis'>(</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T<span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> T<span class='operator'>*</span><span class='parenthesis'>)</span>;

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='keyword'>const</span> T<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> h<span class='parenthesis'>(</span>A<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;

<span class='keyword'>void</span> m<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>const</span> <span class='keyword'>int</span><span class='operator'>*</span> p;
  f<span class='parenthesis'>(</span>p<span class='parenthesis'>)</span>;             <span class='comment'>// <span class='tcode_in_codeblock'>f(const T*)</span> is more specialized than <span class='tcode_in_codeblock'>f(T)</span> or <span class='tcode_in_codeblock'>f(T*)</span></span>
  <span class='keyword'>float</span> x;
  g<span class='parenthesis'>(</span>x<span class='parenthesis'>)</span>;             <span class='comment'>// ambiguous: <span class='tcode_in_codeblock'>g(T)</span> or <span class='tcode_in_codeblock'>g(T&amp;)</span></span>
  A<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span> z;
  h<span class='parenthesis'>(</span>z<span class='parenthesis'>)</span>;             <span class='comment'>// overload resolution selects <span class='tcode_in_codeblock'>h(A&lt;T&gt;&amp;)</span></span>
  <span class='keyword'>const</span> A<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span> z2;
  h<span class='parenthesis'>(</span>z2<span class='parenthesis'>)</span>;            <span class='comment'>// <span class='tcode_in_codeblock'>h(const T&amp;)</span> is called because <span class='tcode_in_codeblock'>h(A&lt;T&gt;&amp;)</span> is not callable</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L4009'>#</a></div><div id='5.note-1' class='note'>[&nbsp;<a class='note_link' href='#5.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='5.sentence-1' class='sentence'>Since, in a call context, such type deduction considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters)<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.example-1' class='example'>[&nbsp;<a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;                            <span class='comment'>// #1</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T<span class='operator'>*</span>, <span class='keyword'>int</span><span class='operator'>=</span><span class='literal'>1</span><span class='parenthesis'>)</span>;                    <span class='comment'>// #2</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;                            <span class='comment'>// #3</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='operator'>*</span>, <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;                      <span class='comment'>// #4</span>

</pre>
<pre class='codeblock'>
<span class='keyword'>int</span> main<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>int</span><span class='operator'>*</span> ip;
  f<span class='parenthesis'>(</span>ip<span class='parenthesis'>)</span>;                                                <span class='comment'>// calls #2</span>
  g<span class='parenthesis'>(</span>ip<span class='parenthesis'>)</span>;                                                <span class='comment'>// calls #4</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='5.example-2' class='example'>[&nbsp;<a class='example_link' href='#5.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;

<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>U, A<span class='anglebracket'>&lt;</span>U, T<span class='anglebracket'>&gt;</span><span class='operator'>*</span> p <span class='operator'>=</span> <span class='literal'>0</span><span class='parenthesis'>)</span>;   <span class='comment'>// #1</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span>         <span class='keyword'>class</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>U, A<span class='anglebracket'>&lt;</span>U, U<span class='anglebracket'>&gt;</span><span class='operator'>*</span> p <span class='operator'>=</span> <span class='literal'>0</span><span class='parenthesis'>)</span>;   <span class='comment'>// #2</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T         <span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T, T <span class='operator'>=</span> T<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;          <span class='comment'>// #3</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T, U <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;         <span class='comment'>// #4</span>

<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  f<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><span class='literal'>42</span>, <span class='parenthesis'>(</span>A<span class='anglebracket'>&lt;</span><span class='keyword'>int</span>, <span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='operator'>*</span><span class='parenthesis'>)</span><span class='literal'>0</span><span class='parenthesis'>)</span>;                          <span class='comment'>// calls #2</span>
  f<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><span class='literal'>42</span><span class='parenthesis'>)</span>;                                           <span class='comment'>// error: ambiguous</span>
  g<span class='parenthesis'>(</span><span class='literal'>42</span><span class='parenthesis'>)</span>;                                                <span class='comment'>// error: ambiguous</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='5.example-3' class='example'>[&nbsp;<a class='example_link' href='#5.example-3'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T, U<span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;          <span class='comment'>// #1</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T            <span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;                <span class='comment'>// #2</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T, <span class='keyword'>class</span><span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='operator'>*</span>, U<span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;         <span class='comment'>// #3</span>
<span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='keyword'>class</span> T            <span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> g<span class='parenthesis'>(</span>T<span class='parenthesis'>)</span>;                <span class='comment'>// #4</span>

<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='keyword'>int</span> i<span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  f<span class='parenthesis'>(</span><span class='operator'>&amp;</span>i<span class='parenthesis'>)</span>;                                                <span class='comment'>// OK: calls #2</span>
  g<span class='parenthesis'>(</span><span class='operator'>&amp;</span>i<span class='parenthesis'>)</span>;                                                <span class='comment'>// OK: calls #3</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0869f240e1b791a7c040d64ea44c435bfb67a237/source/templates.tex#L4062'>#</a></div><div id='6.sentence-1' class='sentence'>If deduction against the other template succeeds for both transformed templates,
constraints can be considered as follows:
<ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div>If their <a class='grammarterm' href='temp.pre#nt:template-parameter-list'>template-parameter-list</a><span class='textit'>s</span>
(possibly including <a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span>
invented for an abbreviated function template (<a href='dcl.fct'>[dcl.fct]</a>)) or
function parameter lists differ in length,
neither template is more specialized than the other.</li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div>Otherwise:
<ul class='itemize'><li id='6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#6.2.1'>(6.2.1)</a></div>If exactly one of the templates was considered by overload resolution
via a rewritten candidate with reversed order of parameters:
<ul class='itemize'><li id='6.2.1.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#6.2.1.1'>(6.2.1.1)</a></div>If, for either template, some of the template parameters
are not deducible from their function parameters,
neither template is more specialized than the other.</li><li id='6.2.1.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#6.2.1.2'>(6.2.1.2)</a></div>If there is either no reordering or more than one reordering
of the associated <a class='grammarterm' href='temp.pre#nt:template-parameter-list'>template-parameter-list</a>
such that
<ul class='itemize'><li id='6.2.1.2.1'><div class='marginalizedparent' style='left:-13em'><a class='marginalized' href='#6.2.1.2.1'>(6.2.1.2.1)</a></div>the corresponding <a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span>
of the <a class='grammarterm' href='temp.pre#nt:template-parameter-list'>template-parameter-list</a><span class='textit'>s</span> are equivalent and</li><li id='6.2.1.2.2'><div class='marginalizedparent' style='left:-13em'><a class='marginalized' href='#6.2.1.2.2'>(6.2.1.2.2)</a></div>the function parameters that positionally correspond
between the two templates are of the same type,</li></ul>
neither template is more specialized than the other.</li></ul></li><li id='6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#6.2.2'>(6.2.2)</a></div>Otherwise, if the corresponding <a class='grammarterm' href='temp.param#nt:template-parameter'>template-parameter</a><span class='textit'>s</span>
of the <a class='grammarterm' href='temp.pre#nt:template-parameter-list'>template-parameter-list</a><span class='textit'>s</span>
are not equivalent (<a href='temp.over.link'>[temp.over.link]</a>) or
if the function parameters that positionally correspond
between the two templates are not of the same type,
neither template is more specialized than the other.</li></ul></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div>Otherwise, if the context in which the partial ordering is done
is that of a call to a conversion function and
the return types of the templates are not the same,
then neither template is more specialized than the other.</li><li id='6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.4'>(6.4)</a></div>Otherwise,
if one template is more constrained than the other (<a href='temp.constr.order'>[temp.constr.order]</a>),
the more constrained template is more specialized than the other.</li><li id='6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.5'>(6.5)</a></div>Otherwise, neither template is more specialized than the other.</li></ul></div> <div id='6.example-1' class='example'>[&nbsp;<a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span><span class='anglebracket'>&gt;</span> <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> True <span class='operator'>=</span> <span class='literal'>true</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span> T<span class='anglebracket'>&gt;</span> <span class='keyword'>concept</span> C <span class='operator'>=</span> True<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span>;

<span class='keyword'>void</span> f<span class='parenthesis'>(</span>C <span class='keyword'>auto</span> <span class='operator'>&amp;</span>, <span class='keyword'>auto</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span> <span class='operator'>=</span> <span class='keyword'>delete</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span>C Q<span class='anglebracket'>&gt;</span> <span class='keyword'>void</span> f<span class='parenthesis'>(</span>Q <span class='operator'>&amp;</span>, C <span class='keyword'>auto</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span>;

<span class='keyword'>void</span> g<span class='parenthesis'>(</span><span class='keyword'>struct</span> A <span class='operator'>*</span>ap, <span class='keyword'>struct</span> B <span class='operator'>*</span>bp<span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  f<span class='parenthesis'>(</span><span class='operator'>*</span>ap, <span class='operator'>*</span>bp<span class='parenthesis'>)</span>;                  <span class='comment'>// OK: Can use different methods to produce template parameters</span>
<span class='curlybracket'>}</span>

<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span> T, <span class='keyword'>typename</span> U<span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> X <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;

<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span><span class='keyword'>typename</span> T, C U, <span class='keyword'>typename</span> V<span class='anglebracket'>&gt;</span> <span class='keyword'>bool</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span><span class='parenthesis'>(</span>X<span class='anglebracket'>&lt;</span>T, U<span class='anglebracket'>&gt;</span>, V<span class='parenthesis'>)</span> <span class='operator'>=</span> <span class='keyword'>delete</span>;
<span class='keyword'>template</span> <span class='anglebracket'>&lt;</span>C T, C U, C V<span class='anglebracket'>&gt;</span>               <span class='keyword'>bool</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span><span class='parenthesis'>(</span>T, X<span class='anglebracket'>&lt;</span>U, V<span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;

<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  X<span class='anglebracket'>&lt;</span><span class='keyword'>void</span> <span class='operator'>*</span>, <span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='curlybracket'>{</span><span class='curlybracket'>}</span> <span class='operator'>=</span><span class='operator'>=</span> <span class='literal'>0</span>;        <span class='comment'>// OK: Correspondence of [<span class='tcode_in_codeblock'>T</span>, <span class='tcode_in_codeblock'>U</span>, <span class='tcode_in_codeblock'>V</span>] and [<span class='tcode_in_codeblock'>U</span>, <span class='tcode_in_codeblock'>V</span>, <span class='tcode_in_codeblock'>T</span>]</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div></div></body></html>