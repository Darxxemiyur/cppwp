<!DOCTYPE html><html lang='en'><head><title>[expr.eq]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.6</a> Compound expressions <a class='abbr_ref' href='expr.compound#expr.eq'>[expr.compound]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.6.10</a> Equality operators <a class='abbr_ref'>[expr.eq]</a></h3><span class='indexparent'><a class='index' id=':expression,equality_operators'></a></span><span class='indexparent'><a class='index' id=':operator,equality'></a></span><span class='indexparent'><a class='index' id=':operator,inequality'></a></span><pre class='bnf'><a class='nontermdef' href='#nt:equality-expression' id='nt:equality-expression'>equality-expression</a><span class='ntdefcolon'>:</span>
&#9;<a class='grammarterm' href='expr.rel#nt:relational-expression'>relational-expression</a>
&#9;<a class='grammarterm' href='#nt:equality-expression'>equality-expression</a> <span class='terminal'><span class='operator'>=</span><span class='operator'>=</span></span> <a class='grammarterm' href='expr.rel#nt:relational-expression'>relational-expression</a>
&#9;<a class='grammarterm' href='#nt:equality-expression'>equality-expression</a> <span class='terminal'><span class='operator'>!</span><span class='operator'>=</span></span> <a class='grammarterm' href='expr.rel#nt:relational-expression'>relational-expression</a>
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6092'>#</a></div><div id='1.sentence-1' class='sentence'>The <span class='texttt'><span class='operator'>=</span><span class='operator'>=</span></span> (equal to) and the <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span> (not equal to) operators
group left-to-right<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>The
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer (<a href='conv.func'>[conv.func]</a>)
standard conversions are performed on the operands<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>The comparison is deprecated if
both operands were of array type
prior to these conversions (<a href='depr.array.comp'>[depr.array.comp]</a>)<a class='hidden_link' href='#1.sentence-3'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6104'>#</a></div><div id='2.sentence-1' class='sentence'>The converted operands shall have arithmetic, enumeration, pointer,
or pointer-to-member type, or type <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>nullptr_&shy;t</span><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>The operators
<span class='texttt'><span class='operator'>=</span><span class='operator'>=</span></span> and <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span> both yield <span class='texttt'><span class='literal'>true</span></span> or <span class='texttt'><span class='literal'>false</span></span>, i.e., a
result of type <span class='texttt'><span class='keyword'>bool</span></span><a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>In each case below, the operands shall have the
same type after the specified conversions have been applied<a class='hidden_link' href='#2.sentence-3'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6111'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':comparison,pointer'></a></span><span class='indexparent'><a class='index' id=':comparison,pointer_to_function'></a></span>If at least one of the operands is a pointer,
<a href='conv.ptr'>pointer conversions</a>,
<a href='conv.fctptr'>function pointer conversions</a>, and
<a href='conv.qual'>qualification conversions</a>
are performed on both operands to bring them to their <a href='expr.type#def:composite_pointer_type'>composite pointer type</a><a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>Comparing pointers is defined as follows:</div><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'>If one pointer represents the address of a complete object, and another
pointer represents the address one past the last element of a different
complete object,<a class='footnotenum' href='#footnote-78' id='footnoteref-78'>78</a>
the result of the comparison is unspecified<a class='hidden_link' href='#3.1.sentence-1'>.</a></div></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'>Otherwise, if the pointers are both null, both point to the same
<span class='indexparent'><a class='index' id=':address'></a></span>function, or both
<a href='basic.compound#def:represents_the_address'>represent the same address</a>,
they compare equal<a class='hidden_link' href='#3.2.sentence-1'>.</a></div></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><div id='3.3.sentence-1' class='sentence'>Otherwise, the pointers compare unequal<a class='hidden_link' href='#3.3.sentence-1'>.</a></div></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6140'>#</a></div><div id='4.sentence-1' class='sentence'>If at least one of the operands is a pointer to member,
pointer-to-member conversions (<a href='conv.mem'>[conv.mem]</a>),
function pointer conversions (<a href='conv.fctptr'>[conv.fctptr]</a>), and
qualification conversions (<a href='conv.qual'>[conv.qual]</a>)
are performed on both operands to bring them to
their composite pointer type (<a href='expr.type'>[expr.type]</a>)<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>Comparing pointers to members is defined as follows:</div><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><div id='4.1.sentence-1' class='sentence'>If two pointers to members are both the null member pointer value, they compare
equal<a class='hidden_link' href='#4.1.sentence-1'>.</a></div></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><div id='4.2.sentence-1' class='sentence'>If only one of two pointers to members is the null member pointer value, they
compare unequal<a class='hidden_link' href='#4.2.sentence-1'>.</a></div></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><div id='4.3.sentence-1' class='sentence'>If either is a pointer to a virtual member function, the result is unspecified<a class='hidden_link' href='#4.3.sentence-1'>.</a></div></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><div id='4.4.sentence-1' class='sentence'>If one refers to a member of class <span class='texttt'>C1</span> and the other refers to a member
of a different class <span class='texttt'>C2</span>, where neither is a base class of the other,
the result is unspecified<a class='hidden_link' href='#4.4.sentence-1'>.</a></div> <div id='4.4.example-1' class='example'>[&nbsp;<a class='example_link' href='#4.4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> B <span class='operator'>:</span> A <span class='curlybracket'>{</span> <span class='keyword'>int</span> x; <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> C <span class='operator'>:</span> A <span class='curlybracket'>{</span> <span class='keyword'>int</span> x; <span class='curlybracket'>}</span>;

<span class='keyword'>int</span> A<span class='operator'>::</span><span class='operator'>*</span>bx <span class='operator'>=</span> <span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>(</span>A<span class='operator'>::</span><span class='operator'>*</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span><span class='operator'>&amp;</span>B<span class='operator'>::</span>x;
<span class='keyword'>int</span> A<span class='operator'>::</span><span class='operator'>*</span>cx <span class='operator'>=</span> <span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>(</span>A<span class='operator'>::</span><span class='operator'>*</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span><span class='operator'>&amp;</span>C<span class='operator'>::</span>x;

<span class='keyword'>bool</span> b1 <span class='operator'>=</span> <span class='parenthesis'>(</span>bx <span class='operator'>=</span><span class='operator'>=</span> cx<span class='parenthesis'>)</span>;   <span class='comment'>// unspecified</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </li><li id='4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.5'>(4.5)</a></div><div id='4.5.sentence-1' class='sentence'>If both refer to (possibly different) members of the same <a href='class.union'>union</a>,
they compare equal<a class='hidden_link' href='#4.5.sentence-1'>.</a></div></li><li id='4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.6'>(4.6)</a></div><div id='4.6.sentence-1' class='sentence'>Otherwise, two pointers to members compare equal if they would refer to the same member of
the same <a href='intro.object#def:most_derived_object'>most derived object</a> or the same subobject if
indirection with a hypothetical object of the associated
class type were performed, otherwise they compare unequal<a class='hidden_link' href='#4.6.sentence-1'>.</a></div> <div id='4.6.example-2' class='example'>[&nbsp;<a class='example_link' href='#4.6.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> B <span class='curlybracket'>{</span>
  <span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> L <span class='operator'>:</span> B <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> R <span class='operator'>:</span> B <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> D <span class='operator'>:</span> L, R <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;

<span class='keyword'>int</span> <span class='parenthesis'>(</span>B<span class='operator'>::</span><span class='operator'>*</span>pb<span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>=</span> <span class='operator'>&amp;</span>B<span class='operator'>::</span>f;
<span class='keyword'>int</span> <span class='parenthesis'>(</span>L<span class='operator'>::</span><span class='operator'>*</span>pl<span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>=</span> pb;
<span class='keyword'>int</span> <span class='parenthesis'>(</span>R<span class='operator'>::</span><span class='operator'>*</span>pr<span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>=</span> pb;
<span class='keyword'>int</span> <span class='parenthesis'>(</span>D<span class='operator'>::</span><span class='operator'>*</span>pdl<span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>=</span> pl;
<span class='keyword'>int</span> <span class='parenthesis'>(</span>D<span class='operator'>::</span><span class='operator'>*</span>pdr<span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>=</span> pr;
<span class='keyword'>bool</span> x <span class='operator'>=</span> <span class='parenthesis'>(</span>pdl <span class='operator'>=</span><span class='operator'>=</span> pdr<span class='parenthesis'>)</span>;          <span class='comment'>// <span class='tcode_in_codeblock'>false</span></span>
<span class='keyword'>bool</span> y <span class='operator'>=</span> <span class='parenthesis'>(</span>pb <span class='operator'>=</span><span class='operator'>=</span> pl<span class='parenthesis'>)</span>;            <span class='comment'>// <span class='tcode_in_codeblock'>true</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6207'>#</a></div><div id='5.sentence-1' class='sentence'>Two operands of type <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>nullptr_&shy;t</span> or one operand of type
<span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>nullptr_&shy;t</span> and the other a null pointer constant compare equal<a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6211'>#</a></div><div id='6.sentence-1' class='sentence'>If two operands compare equal, the result is <span class='texttt'><span class='literal'>true</span></span> for
the <span class='texttt'><span class='operator'>=</span><span class='operator'>=</span></span> operator and <span class='texttt'><span class='literal'>false</span></span> for the <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span> operator<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>If two operands
compare unequal, the result is <span class='texttt'><span class='literal'>false</span></span> for the <span class='texttt'><span class='operator'>=</span><span class='operator'>=</span></span> operator and
<span class='texttt'><span class='literal'>true</span></span> for the <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span> operator<a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>Otherwise, the result of each of the
operators is unspecified<a class='hidden_link' href='#6.sentence-3'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/3a3350ee86fb2dbc86752af66d56102d237d8c4f/source/expressions.tex#L6218'>#</a></div><div id='7.sentence-1' class='sentence'>If both operands are of arithmetic or enumeration type, the <a href='expr.arith.conv'>usual arithmetic
conversions</a> are performed on both operands; each of the operators shall yield
<span class='texttt'><span class='literal'>true</span></span> if the specified relationship is true and <span class='texttt'><span class='literal'>false</span></span> if it is
false<a class='hidden_link' href='#7.sentence-1'>.</a></div></div><div class='footnote' id='footnote-78'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-78'>78)</a></div><div id='footnote-78.sentence-1' class='sentence'>As specified in <a href='basic.compound'>[basic.compound]</a>,
an object that is not an array element is
considered to belong to a single-element array for this purpose<a class='hidden_link' href='#footnote-78.sentence-1'>.</a></div> <a href='#footnoteref-78'>⮥</a></div></div></body></html>